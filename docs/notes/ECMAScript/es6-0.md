### let(变量)

- ​	不属于顶层对象window

`delete`用于删除对象属性

````js
var a = 1;
console.log(a);
console.log("window", window.a);
delete a
console.log(a);//1

b = 2;//不写var---顶层对象或者window属性
console.log(b);
console.log("window", window.b);
delete b
console.log(b);//error	 b is not defined
````

JavaScript作者在设计js时，将顶层对象属性和全局变量进行了挂钩，所以当一个项目很复杂，需要的变量很多时，window上挂载的变量就多，window这个变量就会越大，就会污染全局变量。

````js
let a = 1;
console.log(a);//1
console.log("window测试", window.a);//undefined
````

- 不允许重复声明

````js
var c = 10;
var c =-9;
console.log(c);//-9

var d = 99;
let d = 100;
console.log(d);//'d' has already been declared`
````

- 不存在变量提升

````js
console.log(a); //undefined
var a = 6;

//等价于下面代码
var a;
console.log(a);
a = 6;

//let
console.log(a); //error Cannot access 'a' before initialization
let a = 6;
````

- 暂时性死区

````js
//可以理解为在一个作用域内变量必须先声明再赋值“{}”就是一个作用域.本质就是为了防止变量在声明前使用
var a = 5;
if (true) {
  a = 6;
  var a;
}
//不会报错

var a = 5;
if (true) {
  a = 6;
  let a;
}
//报错，不能在a声明前使用它

//还有一个例子就是
function foo(a = b, b = 2) {
  console.log(a, b);
}
foo(); //会报错
````

- 块级作用域

````js
for (var index = 0; index < 3; index++) {
    console.log("循环内"+index);
}
console.log("循环外"+index);//3

//let
for (let index = 0; index < 3; index++) {
    console.log("循环内"+index);
}
console.log("循环外"+index);//index is not defined
````

````js
if (false) {
    var a = 99;
}
console.log(a);//undefined

//let
if (false) {
    let a = 99;
}
console.log(a);// a is not defined
````

````js
if (true) var a = 6;//正确
if (true) let a = 6;//错误,必须加上花括号证明有作用域,即使只有一条语句

if (true) {
    let a = 6;
}
````

#### 练习题

````js
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); //3个3
  });
}

for (var i = 0; i < 3; i++) {
  (function (j) {
    setTimeout(() => {
      console.log(j); //0 1 2
    });
  })(i);
}
````

1. setTimeout 是异步操作，for循环是同步操作，当setTimeout执行的时候，for循环已经执行完成了。这个时候取到i的值是循环结束以后的值。 
2. 使用闭包可以实现依次输出0，1，2。 
3. 闭包：特点是有一个外部函数和一个内部函数，内部函数会调用内部函数的变量。这时候就能保证外部函数变量的状态不被释放，（里面函数一直引用着外面的值，循环时，i 对应的状态为0， 1， 2 。循环瞬间执行完，但还有这三个状态， 里面就能获取到0，1，2三个值   ） 

### const(常量)

- 不属于顶层对象window

`````js
//es5
Object.defineProperty(window, "PI", {
  value: 3.14,
  writable: false,
});
console.log(PI); //3.14
PI = 99;
console.log(PI); //3.14

//es6-const
const x = 9;
x = 10;
`````

- 不允许重复声明

````js
const x = 9;
const x = 10;//error Identifier 'x' has already been declared
````

- 不存在变量提升

````js
const m;
m = 520;//error Missing initializer in const declaration
````

- 暂时性死区

`````js
if (true) {
  console.log(a);//Error: Cannot access 'a' before initialization
  const a = 9;
}
`````

- 块级作用域

````js
if (true) {
  const a = 9;
}
console.log(a);//error Assignment to constant variable.
````

#### 补充:

js的两种存储方式：栈内存（stack）与堆内存  (heap)

基本数据类型`（number, string,bool,null,undefined）`是直接存在栈内存里的。  引用数据类型`（object、array）`是存在堆内存中的。

![栈堆](https://cdn.jsdelivr.net/gh/webyang-male/yangimgs/imooc-es6-const.png)

````js
const girlObj = {
  name: "许丽儿",
  age: 18,
};
console.log(girlObj);//{name: "许丽儿", age: 18}
girlObj.Adresss = 'HUBEI';
console.log(girlObj);//{name: "许丽儿", age: 18, Adresss: "HUBEI"}

const arr = [1,2,3];
arr.push(4);
console.log(arr);//(4) [1, 2, 3, 4]
````

`const`定义引用数据类型的变量的值是可更改的，因为引用数据类型在栈内存存的是地址，<font style="color:tomato;">只要地址不改变</font>，就不会报错。

##### 浅层冻结`object.freeze(obj)`

只能接受对象，不可以是数组。obj的栈和堆中的值都无法被改变。只冻结对象中的最外面的属性。深层的无法被<font style="color:orange;">直接</font>冻结。

`````js
const girlObj = {
  name: "许丽儿",
  age: 18,
};
console.log(girlObj);//{name: "许丽儿", age: 18}

Object.freeze(girlObj);
girlObj.Adresss = 'HUBEI';
console.log(girlObj);//{name: "许丽儿", age: 18"}
`````

![控制台输出图示](https://cdn.jsdelivr.net/gh/webyang-male/yangimgs/const-Freeze.png)

##### **深层冻结**

````js
//需要手动冻结
Object.freeze(girlObj.skill);
girlObj.skill.name = "coding";
console.log(girlObj);//skill: {name: "ps", year: 1}
````

#### 关于作用域的理解

常见的作用域主要分为几个类型：全局作用域、函数作用域、块状作用域、动态作用域。

<table>
<thead>
<tr>
<th align="center">对象</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">global/window</td>
<td align="center">全局作用域</td>
</tr>
<tr>
<td align="center">function</td>
<td align="center">函数作用域（局部作用域）</td>
</tr>
<tr>
<td align="center">{}</td>
<td align="center">块状作用域</td>
</tr>
<tr>
<td align="center">this</td>
<td align="center">动态作用域</td>
</tr>
</tbody>
</table>

如果一个 变量 或者其他表达式不在 “当前的作用域”，那么JavaScript机制会继续沿着作用域链上查找直到全局作用域（global或浏览器中的window）如果找不到将不可被使用。 作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。

##### 全局作用域

<p>变量在函数或者代码块 <code>{}</code> 外定义，即为全局作用域。不过，在函数或者代码块 <code>{}</code> 内未定义的变量也是拥有全局作用域的（不推荐）。</p>

````js
var temp  = 'es6';

// 此处可调用 temp 变量
function testFn() {
    // 函数内可调用 temp 变量
}
````

<p>上述代码中变量 <code>temp</code> 就是在函数外定义的，它是拥有全局作用域的。这个变量可以在任意地方被读取或者修改，当然如果变量在函数内没有声明（没有使用 var 关键字），该变量依然为全局变量。</p>

````js
// 此处可调用 temp 变量
function testFn() {
    // 函数内可调用 temp 变量
    temp  = 'es6';
}
````

以上实例中 temp 在函数内，但是拥有全局作用域，它将作为 global 或者 window 的属性存在。

<blockquote>
  <p>在函数内部或代码块中没有定义的变量实际上是作为 window/global 的<font style="color:red;font-size:18px;">属性</font>存在，而不是全局变量。换句话说没有使用 var 定义的变量虽然拥有全局作用域，但是它是可以被 delete 的，而全局变量不可以。<br>
参考：<a href="https://www.runoob.com/js/js-scope.html">https://www.runoob.com/js/js-scope.html</a></p>
</blockquote>


##### 函数作用域

在函数内部定义的变量，就是局部作用域。函数作用域内，对外是封闭的，从外层的作用域无法直接访问函数内部的作用域！

````js
function fun() {
    var testValue = 'hello';
}
console.log(testValue);//error testValue is not defined
````

如果想读取函数内的变量，必须借助 return 或者闭包。

`````js
function fn(params) {
    var testValue = "大赵同学,";
    return testValue + params
}
console.log(fn('hello'));//大赵同学,hello
`````

这是借助 return 的方式，下面是<font style="color:pink;">闭包</font>的方式：

````js
function strFn(params) {
    var testValue = "大赵同学,";
    var result = testValue + params

    function innser() {
        return result;
    }
    return innser();
}
console.log(strFn('hello'));//大赵同学,hello
````

通俗的讲，return 是函数对外交流的出口，而 return 可以返回的是函数，根据作用域的规则，函数内部的子函数是可以获取函数作用域内的变量的。

##### 块状作用域

````js
if (true) {
    let a = 1
    console.log(a)
}
````

在这个代码中， if 后 `{ } `就是“块”，这个里面的变量就是拥有这个块状作用域，按照规则，` { } `之外是无法访问这个变量的。

##### 动态作用域

````js
window.a = 3

function test() {
    console.log(this.a)
}

test.bind({
    a: 2
})() // 2
test() // 3
````

 bind 已经把作用域的范围进行了修改指向了 ``{ a: 2 }``，而 this 指向的是当前作用域对象

````js
var course = " es"

// 此处可调用 course 变量
function myFunction() {
    // 函数内可调用 course 变量
}
````

 写代码的时候就知道 course 就是全局作用域，函数内部的用 var 定义的变量就是函数作用域。这个也就是专业术语：词法作用域。
		通俗的讲变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。
相反，只能在执行阶段才能决定变量的作用域，那就是动态作用域。

#### 推荐阅读

- [什么是作用域](https://www.kancloud.cn/kancloud/you-dont-know-js-scope-closures/516610)
- [JavaScript深入之词法作用域和动态作用域](https://github.com/mqyqingfeng/Blog/issues/3)
- [深入理解JS中声明提升、作用域（链）和 this 关键字](https://github.com/creeperyang/blog/issues/16)

### 解构赋值

#### 数组解构

````js
/* 
let arr = [1,2,3];
let a = arr[0];
let b = arr[1];
let c = arr[2];
console.log(a,b,c);//1,2,3
*/

//es6解构demo
let [a,b,c] = [1,2,3];
console.log(a,b,c);//1,2,3

let [a,b,[c,d]] = [1,2,[3,4]];
console.log(a,b,c,d);//1,2,3,4

let [a,b,[c]] = [1,2,[3,4]];
console.log(a,b,c,d);//1,2,3

let [a,b,c] = [1,2,[3,4]];
console.log(a,b,c);//1,2,[3,4]

let [a,b,c,d] = [1,2,[3,4]];
console.log(a,b,c,d);//1 2 [3, 4] undefined

let [a, b, c=18] = [1, 2];
console.log(a, b, c, d); //1 2 18

let [a, b, c, d = 666] = [1, 2, [3, 4]];
console.log(a, b, c, d); //1 2 [3, 4] 666

let [a, b, c, d = 666] = [1, 2, [3, 4],520];
console.log(a, b, c, d); //1 2 [3, 4] 520
````

数组解构赋值：等号两边类型要一致。    等号两边数量相等，则一一对应。左边有默认值，也依旧赋值为右边的值。    若左边的比右边多且没有默认值，则为undefined； 若有默认值则为默认值。    若左边比右边少，则只对应自己对应的值，其他不管。       

#### 对象解构赋值

赋值的顺序任意，只要对应上右侧对象的key值就可以  

若命名想换一下则 原名字 : 新名字

`````js
let user = {
  name: "大赵",
  age: 21,
};
// let name = user.name;
// let age = user.age;

//等价于
let {name,age} = user;
console.log(name,age);//大赵 21
//等价于
let {age,name} = user;
console.log(name,age);//大赵 21

//别名
let { age: uage, name: uname } = user;
console.log(uname, uage); //大赵 21
`````

#### 字符串解构赋值

字符串解构赋值与数组解构赋值相同。

`````js
let str = "imooc";
// for (let i = 0; i < str.length; i++) {
//    console.log(str[i]);
// }

let [a,b,c,d,e] = str;
console.log(a,b,c,d,e);//i m o o c
`````

#### 惰性解构赋值

> 解构赋值属于惰性赋值，有传递就不用默认值。 

若右边数组中没有值，则执行foo()，控制台输出123, 若右边数组有值则a赋值为1 

````js
function foo() {
  console.log(123);
}
//let [a = foo()] = [1];//无输出
let [a = foo()] = [];//123
````

#### 解构赋值应用

````js
function foo([a, b, c]) {
  console.log(a, b, c);//123
}
let arr = [1,2,3];
foo(arr);
````

````js
function foo({name,age,addr}) {
  console.log(name,age,addr);//李霞 18 HuBei
}
let obj = {
    name:"李霞",
    age: 18,
    addr: "HuBei"
};
foo(obj);
````

`````js
function foo({ name, age, addr, school = "Tsinghua" }) {
  console.log(name, age, addr, school); //许丽 18 HuBei Tsinghua
}
let obj = {
  name: "许丽",
  age: 18,
  addr: "HuBei",
};
foo(obj);
`````

`````js
function foo() {
  let obj = {
    name: "许丽",
    age: 18,
    addr: "HuBei",
  };
  return obj;
}
let {name,age} = foo();
console.log(name,age);//许丽 18
`````

`````js
//json
let json = '{"a": "hello", "b": "world"}'
let {a, b} = JSON.parse(json)
console.log( a, b )     
`````

### ES5数组遍历方式
