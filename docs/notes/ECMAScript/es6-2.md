### 异步操作前置知识

#### JavaScript单线程

> JavaScript为什么要设计成<font style="color:gold;">单线程</font>？
>
> 首先，我们应该明确的是单线程和多线程这两种方式，并不是谁一定好或者谁一定不好，只是两种不同的方式。
>
> 然后，每种语言设计的方式一定是和他的用途有关的，js的主要用途就是操作dom，为了避免操作dom冲突那么单线程就比较合适。虽然可以使用多线程再加一些锁的概念可以来避免冲突，但这样会增加语言的复杂性。所以js在一开始设计的时候就被设计成了单线程。

![](https://cdn.jsdelivr.net/gh/webyang-male/yangimgs/JavaScriptSync-xmind.png)

````js
// 1 3 2
console.log(1)
setTimeout(() => {
    console.log(2)
}, 0)
console.log(3)
````

#### Ajax原理与Callback Hell

##### Ajax原理

````js
// 1、创建XMLHttpRequest对象
var xmlhttp;
if (window.XMLHttpRequest) {
  xmlhttp = new XMLHttpRequest();
} else {
  // 兼容早期浏览器
  xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
}
// 2、发送请求
xmlhttp.open("GET", url, true);
xmlhttp.send();
// 3、服务端响应
xmlhttp.onreadystatechange = function () {
  if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {
    var obj = JSON.parse(xmlhttp.responseText);
    console.log(obj);

  }
};
````

##### 封装

````js
function ajax(url, callback) {
    // 1、创建XMLHttpRequest对象
    var xmlhttp
    if (window.XMLHttpRequest) {
        xmlhttp = new XMLHttpRequest()
    } else { // 兼容早期浏览器
        xmlhttp = new ActiveXObject('Microsoft.XMLHTTP')
    }
    // 2、发送请求
    xmlhttp.open('GET', url, true)
    xmlhttp.send()
    // 3、服务端响应
    xmlhttp.onreadystatechange = function () {
        if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {
            var obj = JSON.parse(xmlhttp.responseText)
            // console.log(obj)
            callback(obj)
        }
    }
}

// var url = 'http://musicapi.xiecheng.live/personalized'
// ajax(url, res => {
//     console.log(res)
// })
````

##### Callback Hell

函数是异步调用的，因为操作不是立即完成的，而是之后才会完成。

```js
ajax('/static/a.json')
// 下面的代码不会等到ajax执行完才执行
// ...
```

这个过程大家并不陌生，可是如果在回调之后再回调呢？

```js
ajax('static/a.json', res => {
    console.log(res)
    ajax('static/b.json', res => {
        console.log(res)
        ajax('static/c.json', res => {
            console.log(res)
        })
    })
})
```

如果嵌套变多，代码层次就会变深，维护难度也随之增加。

这就被称为 “回调地狱” 或者“回调深渊”。

### Promise

#### 基本语法

Promise 就是为了解决“回调地狱”问题的，它可以将异步操作的处理变得很优雅。回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象promise可以支持多个并发的请求，获取并发请求中的数据这个promise可以解决异步的问题，本身不能说promise是异步的。

创建Promise实例:

````js
const promise = new Promise(function(resolve, reject) {
    // ... some code

    if ( /* 异步操作成功 */ ) {
        resolve(value)
    } else {
        reject(error)
    }
})
````

