### 面向过程 与  面向对象       

> JavaScript是一种基于对象的语言

面向过程是一件事“该怎么做“，面向对象是一件事“该让谁来做”，然后那个“谁”就是对象，他要怎么做是他自己的事，反正最后一群对象合力能把事做好就行了。 				------ 知乎

#### 类和对象

类(class)是对象(object)的模板，定义了同一组对象共有的属性和方法

### 类与继承

#### ES5中的类与继承

##### 类

> 静态方法里的this指向构造函数
>
> 构造函数this指向实例化对象

````js
// 类
function People(name, age) {
    // console.log(this)
    this.name = name
    this.age = age
}
// 实例方法
People.prototype.showName = function () {
    console.log('我的名字是' + this.name)
}
// {name: 'LX', age: 18}
// 我的名字是LX
// {name: 'zhangsan', age: 18}
// 我的名字是zhangsan
let p1 = new People('LX', 18)
console.log(p1)
p1.showName()

let p2 = new People('zhangsan', 18)
console.log(p2)
p2.showName()
````

> 一般情况下，方法不会写在构造函数下(每次实例化都会有一个方法) 一般放在原型上 

```js
// 类
function People(name, age) {
    // console.log(this)
    // 实例属性
    this.name = name
    this.age = age
    People.count++
}
// 静态属性
People.count = 0
// 静态方法
People.getCount = function(){
  /* ƒ People(name, age) {
    console.log(this); // 实例属性
    this.name = name;
    this.age = age;
    People.count++;
  } */
    console.log(this)//指向构造函数
    console.log(this.age) // undefined
    console.log('当前共有' + People.count + '个人')
}

// 实例方法
People.prototype.showName = function () {
    console.log('我的名字是' + this.name)
}

//p1,p2实例化对象
let p1 = new People('lx', 18)
console.log(p1)
p1.showName()

let p2 = new People('zhangsan', 20)
console.log(p2)
p2.showName()

console.log(People.count)
People.getCount()//静态方法调用

// let str = new String('imooc')
// console.log(str)

// let arr = new Array(1, 2, 3)
// console.log(arr)

// let obj = new Object()
// obj.name = 'zain'
// console.log(obj)

// 静态方法
// console.log(Math.max(4, 5))
// console.log(Math.random())
```

##### 继承

> 构造函数继承只能继承父类的属性，原型的继承可以继承方法

`````js
// 父类
function Animal(name) {
    this.name = name
}
Animal.prototype.showName = function () {
    console.log('名字是:' + this.name)
}

// 子类
function Dog(name, color) {
    Animal.call(this, name) // 构造函数继承属性
    this.color = color
}
//原型继承方法
Dog.prototype = new Animal()
//prototype的constructor属性应该是指向它的构造函数的。
//上面这一句让Dog.prototype.constructor指向了Animal，所以需要改回Dog
Dog.prototype.constuctor = Dog

let d1 = new Dog('wangcai', 'white')
console.log(d1)
d1.showName()
//Dog {name: 'wangcai', color: 'white'}
//名字是:wangcai
`````

#### ES6中的类与继承

````js
class People {
    constructor(name, age) {//构造函数constructor
        this.name = name
        this.age = age
        this._sex = -1
    }
    // static count = 0
    get sex() { // 属性
        if (this._sex === 1) {
            return 'male'
        } else if (this._sex === 0) {
            return 'female'
        } else {
            return 'error'
        }
    }
    set sex(val) { // 1:male 0:female
        if (val === 0 || val === 1) {
            this._sex = val
        }
    }
    showName() {
        console.log(this.name)
    }
    // 静态方法
    static getCount() {
        return 5
    }
}
// 静态属性
People.count = 9
console.log(typeof People) // function
console.log(People.count)

let p1 = new People('zain', 18)
console.log(p1)
p1.sex = 5
console.log(p1.sex)
console.log(People.getCount())

//extends实现类之间的继承
class Coder extends People {
    constructor(name, age, company) {
        super(name, age)//super关键字继承父类属性和方法
        this.company = company
    }
    showCompany() {
        console.log(this.company)
    }
}

let c1 = new Coder('zhangsan', 25, 'imooc')
console.log(c1)
c1.showName()
c1.showCompany()
c1.sex = 1
console.log(c1.sex)
console.log(Coder.getCount())
````

##### ✒【拓展理解】

​		<font style="color:deepskyblue;">class实现继承的注意事项</font>

1、class 声明不会提升。Foo 进入暂时性死区，类似于 let、const 声明变量

````js
const bar = new Bar(); // it's ok
function Bar() {
  this.bar = 42;
}

const foo = new Foo(); // ReferenceError: Foo is not defined
class Foo {
  constructor() {
    this.foo = 42;
  }
}
````

2、class 声明内部会启用严格模式

````js
// 引用一个未声明的变量
function Bar() {
  baz = 42; // it's ok
}
const bar = new Bar();

class Foo {
  constructor() {
    fol = 42; // ReferenceError: fol is not defined
  }
}
const foo = new Foo();
````

3、class 的所有方法（包括静态方法和实例方法）都是不可枚举的

````js
// 引用一个未声明的变量
function Bar() {
  this.bar = 42;
}
Bar.answer = function() {
  return 42;
};
Bar.prototype.print = function() {
  console.log(this.bar);
};
const barKeys = Object.keys(Bar); // ['answer']
const barProtoKeys = Object.keys(Bar.prototype); // ['print']

class Foo {
  constructor() {
    this.foo = 42;
  }
  static answer() {
    return 42;
  }
  print() {
    console.log(this.foo);
  }
}
const fooKeys = Object.keys(Foo); // []
const fooProtoKeys = Object.keys(Foo.prototype); // []
````

4、class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用

````js
function Bar() {
  this.bar = 42;
}
Bar.prototype.print = function() {
  console.log(this.bar);
};

const bar = new Bar();
const barPrint = new bar.print(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
  print() {
    console.log(this.foo);
  }
}
const foo = new Foo();
const fooPrint = new foo.print(); // TypeError: foo.print is not a constructor
````

5、必须使用 new 调用 class

```js
function Bar() {
  this.bar = 42;
}
const bar = Bar(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
}
const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new'
```

6、class 内部无法重写类名

```js
function Bar() {
  Bar = 'Baz'; // it's ok
  this.bar = 42;
}
const bar = new Bar();
// Bar: 'Baz'
// bar: Bar {bar: 42}  

class Foo {
  constructor() {
    this.foo = 42;
    Foo = 'Fol'; // TypeError: Assignment to constant variable
  }
}
const foo = new Foo();
Foo = 'Fol'; // it's ok
```

### 原始数据类型Symbol

> ES6 引入了一种新的原始数据类型 `Symbol` ，表示独一无二的值。

#### 声明方式

1.简单声明(难以理解其代表意义)

````js
let s1 = Symbol()
let s2 = Symbol()
console.log(s1)
console.log(s2)
console.log(s1 === s2) // false
````

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></div>

2.字符串声明

> Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

````js
let s1 = Symbol('foo')
let s2 = Symbol('bar')
console.log(s1)
console.log(s2)
console.log(s1 === s2)// false
````

3.对象方法

`````js
const obj = {
    name: 'imooc',
    toString() {
        return this.name
    }
}
let s = Symbol(obj)
console.log(s)//Symbol(imooc)
`````

#### 1个API

````js
let s = Symbol('foo')
console.log(s.description)//foo
````

#### Symbol.for()

`Symbol.for()` 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到`全局`。

```js
let s1 = Symbol.for('foo')
let s2 = Symbol.for('foo')
console.log(s1 === s2) // true
```

````js
function foo() {
    return Symbol.for('foo')
}
const x = foo()
const y = Symbol.for('foo')
console.log(x === y) // true
````

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。</p></div>

#### Symbol.keyFor()

> Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。

```js
const s1 = Symbol('foo')
console.log(Symbol.keyFor(s1)) // undefined

const s2 = Symbol.for('foo')
console.log(Symbol.keyFor(s2)) // foo
```

#### 使用场景

##### 作为属性名

由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。

比如在一个班级中，可能会有同学名字相同的情况，这时候使用对象来描述学生信息的时候，如果直接使用学生姓名作为key会有有问题。

```js
const grade = {
    张三: {
        address: 'xxx',
        tel: '111'
    },
    李四: {
        address: 'yyy',
        tel: '222'
    },
    李四: {
        address: 'zzz',
        tel: '333'
    },
}
console.log(grade)
// 只会保留最后一个李四
```

如果使用Symbol，同名的学生信息就不会被覆盖：

```js
const stu1 = Symbol('李四')
const stu2 = Symbol('李四')
const grade = {
    [stu1]: {
        address: 'yyy',
        tel: '222'
    },
    [stu2]: {
        address: 'zzz',
        tel: '333'
    },
}
console.log(grade)
console.log(grade[stu1])
console.log(grade[stu2])
```

##### 属性遍历

````js
const sym = Symbol('imooc')
class User {
    constructor(name) {
        this.name = name
        this[sym] = 'imooc.com'
    }
    getName() {
        return this.name + this[sym]
    }
}
const user = new User('xiecheng')
console.log(user.getName())

for (let key in user) {
    console.log(key)
}

for (let key of Object.keys(user)) {
    console.log(key)
}

for (let key of Object.getOwnPropertySymbols(user)) {
    console.log(key)
}
//正常遍历出
for (let key of Reflect.ownKeys(user)) {
    console.log(key)
}
````

##### 消除魔术字符串

魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。

```js
function getArea(shape) {
    let area = 0
    switch (shape) {
        case 'Triangle':
            area = 1
            break
        case 'Circle':
            area = 2
            break
    }
    return area
}
console.log(getArea('Triangle'))
```

上面代码中，字符串Triangle和Circle就是魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。

使用Symbol就可以很好的解决这个问题：

```js
const shapeType = {
    triangle: Symbol(),
    circle: Symbol()
}

function getArea(shape) {
    let area = 0
    switch (shape) {
        case shapeType.triangle:
            area = 1
            break
        case shapeType.circle:
            area = 2
            break
    }
    return area
}
console.log(getArea(shapeType.triangle))
```

###  Set

在 JavaScript 里通常使用 Array 或 Object 来存储数据。但是在频繁操作数据的过程中查找或者统计并需要手动来实现，并不能简单的直接使用。 比如如何保证 Array 是去重的，如何统计 Object 的数据总数等，必须自己去手动实现类似的需求，不是很方便。 在 ES6 中为了解决上述痛点，新增了数据结构 Set 和 Map，它们分别对应传统数据结构的“集合”和“字典”。

> ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

#### 基本语法

##### 生成 Set 实例

```js
  let s = new Set()
```

可以定义一个空的 Set 实例，也可以在实例化的同时传入默认的数据。

```js
  let s = new Set([1, 2, 3, 4])
```

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>初始化的参数必须是可遍历的，可以是数组或者自定义遍历的数据结构。</p></div>

##### 添加数据

```js
  s.add('hello')
  s.add('LX')
```

或者

```js
  s.add('hello').add('许丽')
```

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>Set 数据结构不允许数据重复，所以添加重复的数据是无效的</p></div>

##### 删除数据

删除数据分两种，一种是删除指定的数据，一种是删除全部数据。

```js
  // 删除指定数据
  s.delete('hello') // true
  // 删除全部数据
  s.clear()
```

##### 统计数据

Set 可以快速进行统计数据，如数据是否存在、数据的总数。

```js
  // 判断是否包含数据项，返回 true 或 false
  s.has('hello') // true
  // 计算数据项总数
  s.size // 2
```

#### ⚙️应用场景

##### 数组去重

```js
let arr = [1, 2, 3, 4, 2, 3]
let s = new Set(arr)
console.log(s)
```

##### 合并去重

```js
let arr1 = [1, 2, 3, 4]
let arr2 = [2, 3, 4, 5, 6]
let s = new Set([...arr1, ...arr2])
console.log(s)
//转为数组
console.log([...s])
console.log(Array.from(s))
```

##### 交集

```js
let s1 = new Set(arr1)
let s2 = new Set(arr2)
let result = new Set(arr1.filter(item => s2.has(item)))
console.log(Array.from(result))
```

##### 差集

```js
let arr3 = new Set(arr1.filter(item => !s2.has(item)))
let arr4 = new Set(arr2.filter(item => !s1.has(item)))
console.log(arr3)
console.log(arr4)
console.log([...arr3, ...arr4])
```

#### 遍历

- keys()：返回键名的遍历器
- values()：返回键值的遍历器
- entries()：返回键值对的遍历器
- forEach()：使用回调函数遍历每个成员
- for...of：可以直接遍历每个成员

```js
let s  =new Set(["hi","lx"]);
console.log(1,s.keys()) // Set { 'lx', 'hi' }
console.log(2,s.values()) // Set { 'hi', 'lx' }
console.log(3,s.entries()) // Set { 'hi', 'lx' }
s.forEach(item => {
    console.log(4,item) 
})

for (let item of s) {
    console.log(5,item)
}

for (let item of s.keys()) {
    console.log(6,item)
}

for (let item of s.values()) {
    console.log(7,item)
}

for (let item of s.entries()) {
    console.log(item[0], item[1])
}
```

![](https://fastly.jsdelivr.net/gh/webyang-male/yangimgs/set-1.png)

####  WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

WeakSet 的成员只能是对象，而不能是其他类型的值。

```js
const ws = new WeakSet()
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set
let ws = new WeakSet()
const obj1 = {
    name: 'imooc'
}
const obj2 = {
    age: 5
}
ws.add(obj1)
ws.add(obj2)
ws.delete(obj1)
console.log(ws)
console.log(ws.has(obj2))
```

<font style="color:darkorange;">WeakSet 没有size属性，没有办法遍历它的成员。</font>

WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

### Map

ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

#### 实例化

```js
  let map = new Map([iterable])
```

Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ], [ 2, 'two' ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。

#### 添加数据

```js
  let keyObj = {}
  let keyFunc = function() {}
  let keyString = 'a string'

  // 添加键
  map.set(keyString, "和键'a string'关联的值")
  map.set(keyObj, '和键keyObj关联的值')
  map.set(keyFunc, '和键keyFunc关联的值')
```

````js
let m = new Map()
let obj = {
    name: 'imooc'
}
m.set(obj, 'es')
console.log(m.get(obj))//es
m.delete(obj)
console.log(m)// Map(0)
````

#### 删除数据

```js
  // 删除指定的数据
  map.delete(keyObj)
  // 删除所有数据
  map.clear()
```

#### 统计数据

```js
  // 统计所有 key-value 的总数
  console.log(map.size) //2
  // 判断是否有 key-value
  console.log(map.has(keyObj)) // true
```

````js
let map = new Map([
    ['name', 'tb'],
    ['age', 18]
])
console.log(map.size)//2
console.log(map.has('name'))//true
console.log(map.get('age'))//18
map.set('name', 'zhangsan')
map.delete('name')
console.log(map)//Map(1) {'age' => 5}
````

#### 查询数据

get() 方法返回某个 Map 对象中的一个指定元素

```js
  console.log(map.get(keyObj)) // 和键keyObj关联的值
```

#### 遍历方式

- keys() 返回一个新的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的 key 值
- values() 方法返回一个新的 Iterator 对象。它包含按顺序插入Map对象中每个元素的 value 值
- entries() 方法返回一个新的包含 [key, value] 对的 Iterator ? 对象，返回的迭代器的迭代顺序与 Map 对象的插入顺序相同
- forEach() 方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数
- for...of 可以直接遍历每个成员

```js
   map.forEach((value, key) => console.log(value, key))

   for (let [key, value] of map) {
       console.log(key, value)
   }

   for (let key of map.keys()) {
       console.log(key)
   }

   for (let value of map.values()) {
       console.log(value)
   }

   for (let [key, value] of map.entries()) {
       console.log(key, value)
   }
```

<font style="color:gold;">其实 Object 也是按键值对存储和读取的，那么他俩之间除了我们之前说的区别以外还有其他的吗？</font>

- **键的类型**

  一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。

- **键的顺序**

  Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。

- **键值对的统计**

  你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。

- **键值对的遍历**

  Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。

- **性能**

  Map 在涉及频繁增删键值对的场景下会有些性能优势。
  

  <font style="color:deepskyblue;">map应用场景：判断对象有没有某个key有has方法、size方法直接获取对虾干属性的个数、属性名的种类更多样、性能比对象更好</font>

#### WeekMap

WeakMap结构与Map结构类似，也是用于生成键值对的集合。

```js
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap()
const key = {
    foo: 1
}
wm1.set(key, 2)
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3]
const k2 = [4, 5, 6]
const wm2 = new WeakMap([
    [k1, 'foo'],
    [k2, 'bar']
])
wm2.get(k2) // "bar"
```

WeakMap与Map的区别有两点。

- WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。

```js
const map = new WeakMap()
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
```

- WeakMap的键名所指向的对象，不计入垃圾回收机制。

  

  ````js
  let wm = new WeakMap()
  let elem = document.getElementsByTagName('h1')
  wm.set(elem, 'info')
  console.log(wm.get(elem))
  ````

<em>这里elem被引用了一次，垃圾回收机制记录elem这个节点引用次数一次，weakmap是弱引用，wm.set(elem,'info'),这里又引用一次，但不会进入垃圾回收机制，引用次数不会增加，所以elem这个元素总的引用次数是一次，如果有一天，这个元素被删掉，垃圾回收机制引用次数变为0，weakmap是弱引用，对被删除元素的引用并不会影响垃圾回收机制的记录次数，此时是0，所以这里的elem对象被回收，对应weakmap里面的键值对也会消失，所以weakmap这种数据结构是有助于防止内存泄漏的，这就是weakmap的应用场景</em>

📝WeakMap：键名只支持引用类型（数组、对象、function），对对象的引用是弱引用

​	不支持clear、size方法、不能遍历、也是弱引用类型

### String扩展

#### Unicode表示法

ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。

```js
"\u0061"
// "a"
```

但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。

```js
"\uD842\uDFB7"
// "𠮷"

"\u20BB7"
// " 7"
```

上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。

ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。

```js
"\u{20BB7}"
// "𠮷"
```

有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。

```js
'\z' === 'z' // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

#### 遍历器接口

ES6 为字符串添加了遍历器接口，详见Iterator，使得字符串可以被for...of循环遍历。

```js
for (let item of 'CHINA') {
    console.log(item)
}
```

#### <font style="color:darkorange;">模板字符串</font>

在模板字符串语句中可以任意插入变量或者表达式，只要用[``${}``]包起来就好。

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>这里的符号是反引号，也就是数字键 1 左边的键，不是单引号或者双引号</p></div>

##### 换行

这样就可以轻松解决字符串包含变量或者表达式的问题了，对于多行的字符串，之前是这样处理

```js
console.log('string text line 1\n' +
    'string text line 2')
// "string text line 1
// string text line 2"
```

现在可以这样做了

```js
console.log(`string text line 1
string text line 2`)
// "string text line 1
// string text line 2"
```

##### Tag Literals	

前面的字符串字面量解决了字符串拼接的问题，对于包含复杂逻辑的字符串并不是简单的表达式能搞定的。所以需要另一种解决方案：Tag Literals

```js
var retailPrice = 20
var wholesalePrice = 16
var type = 'retail'

var showTxt = ''

if (type === 'retail') {
    showTxt += '您此次的购买单价是：' + retailPrice
} else {
    showTxt += '您此次的批发价是：' + wholesalePrice
}
```

现在可以定义一个 Tag 函数，然后用这个 Tag 函数来充当一个模板引擎：

```js
function Price(strings, type) {
    let s1 = strings[0]
    const retailPrice = 20
    const wholesalePrice = 16
    let txt = ''
    if (type === 'retail') {
        txt = `购买单价是：${retailPrice}` 
    } else {
        txt = `批发价是：${wholesalePrice}` 
    }
    return `${s1}${txt}` 
}

let showTxt = Price `您此次的${'retail'}` 

console.log(showTxt) //您此次的购买单价是：20
```

> TIP
>
> strings 参数指的是 Tag 函数后面被变量分割开的字符串集合，type 参数是对应第一个变量，Tag 函数可以有多个 type 类似的参数

#### 扩展方法

##### String.prototype.fromCodePoint()

用于从 Unicode 码点返回对应字符，并且可以识别大于0xFFFF的字符。

```js
// ES5
console.log(String.fromCharCode(0x20BB7))	//打印未知符号,因为es5最大支持码点不超过FFFF

// ES6
console.log(String.fromCodePoint(0x20BB7))
```

##### String.prototype.includes()

ES5中可以使用indexOf方法来判断一个字符串是否包含在另一个字符串中，indexOf返回出现的下标位置，如果不存在则返回-1。

```js
const str = 'imooc'

console.log(str.indexOf('mo'))
```

ES6提供了includes方法来判断一个字符串是否包含在另一个字符串中，返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.includes('mo'))
```

##### String.prototype.startsWith()

判断参数字符串是否在原字符串的头部, 返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.startsWith('im'))
```

##### String.prototype.endsWith()

判断参数字符串是否在原字符串的尾部, 返回boolean类型的值。

```js
const str = 'imooc'

console.log(str.endsWith('mooc'))
```

##### String.prototype.repeat()

repeat方法返回一个新字符串，表示将原字符串重复n次。

```js
const str = 'imooc'

const newStr = str.repeat(10)

console.log(newStr)
```

###  RegExp

#### y修饰符

ES6为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。

y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

```js
const s = 'aaa_aa_a'
const r1 = /a+/g
const r2 = /a+/y

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是`_aa_a`。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从`头部`开始，所以返回null。

如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。

```js
const s = 'aaa_aa_a'
const r = /a+_/y

r.exec(s) // ["aaa_"]
r.exec(s) // ["aa_"]
```

```js
const s = 'aaa_aa_a'
const r = /a+_/y

r.exec(s) // ["aaa_"]
r.exec(s) // ["aa_"]
```

上面代码每次匹配，都是从剩余字符串的头部开始。

使用lastIndex属性，可以更好地说明y修饰符。

```js
const regexp = /a/g

// 指定从2号位置（y）开始匹配
regexp.lastIndex = 2

// 匹配成功
const match = regexp.exec('xaya')

// 在3号位置匹配成功
console.log(match.index) // 3

// 下一次匹配从4号位开始
console.log(regexp.lastIndex) // 4

// 4号位开始匹配失败
regexp.exec('xaxa') // null
```

上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。

y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。

```js
const regexp = /a/y

// 指定从2号位置开始匹配
regexp.lastIndex = 2

// 不是粘连，匹配失败
regexp.exec('xaya') // null

// 指定从3号位置开始匹配
regexp.lastIndex = 3

// 3号位置是粘连，匹配成功
const match = regexp.exec('xaxa')
console.log(match.index) // 3
console.log(regexp.lastIndex) // 4
```

进一步说，y修饰符号隐含了头部匹配的标志^。

```js
const reg = /b/y
reg.exec('aba')
// null
console.log(reg.lastIndex)
```

> TIP
>
> sticky 模式在正则匹配过程中只会影响两件事：
>
> - 匹配必须从 re.lastIndex 开始（相当于正则表达中的 ^）
> - 如果匹配到会修改 re.lastIndex（相当于 g 模式）

#### u修饰符

ES6为正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于 `\uFFFF` 的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。

````js
// u修饰符 unicode
// \u0000~\uffff
const str = '\uD842\uDFB7' // 表示一个字符
console.log(/^\uD842/.test(str)) // es5 true
console.log(/^\uD842/u.test(str)) // es6 false
````

上面代码中， `\uD83D\uDC2A` 是一个四个字节的UTF-16编码，代表一个字符 "🐪"。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为false。

一旦加上u修饰符号，就会修改下面这些正则表达式的行为:

**(1) 点字符**

点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上u修饰符。

````js
const str = '\uD842\uDFB7' // 表示一个字符

// .除了换行符以外的任意单个字符
console.log(/^.$/.test(str)) // false
console.log(/^.$/u.test(str)) // true
````

上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。

**(2) Unicode字符表示法**

ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。

````js
console.log(/\u{61}/.test('a')) // false

console.log(/\u{61}/u.test('a')) // true
````

上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配61个连续的u。

**(3) 量词**

使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。

```js
console.log(/𠮷{2}/.test('𠮷𠮷')) // false

console.log(/𠮷{2}/u.test('𠮷𠮷')) // true
```

只有在使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。

```js
/^\u{3}$/.test('uuu') // true
```

上面代码中，由于正则表达式没有u修饰符，所以大括号被解读为量词。加上u修饰符，就会被解读为Unicode表达式。

```js
/\u{20BB7}{2}/u.test('𠮷𠮷') // true
```

使用 u 修饰符之后 Unicode 表达式+量词也是可以的。

**(4) 预定义模式**

u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。

```js
/^\S$/.test('𠮷') // false

/^\S$/u.test('𠮷') // true
```

上面代码的\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。

利用这一点，可以写出一个正确返回字符串长度的函数。

```js
function codePointLength(text) {
    const result = text.match(/[\s\S]/gu)
    return result ? result.length : 0
}

const s = '𠮷𠮷'

s.length // 4
codePointLength(s) // 2
```

**(5) i修饰符**

有些Unicode字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。

```js
/[a-z]/i.test('\u212A') // false

/[a-z]/iu.test('\u212A') // true
```

上面代码中，不加u修饰符，就无法识别非规范的K字符。

### Number                数值的扩展

十进制转化为二进制

````js
const a = 5 // 101

console.log(a.toString(2))
````

十进制转化为二进制

````js
const b = 101

console.log(parseInt(b, 2))
````

ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。

```js
const a = 0B0101
console.log(a)

const b = 0O777
console.log(b)
```

#### 新增方法

##### Number.isFinite()

用来检查一个数值是否为有限的（finite），即不是Infinity。

```js
Number.isFinite(15) // true
Number.isFinite(0.8) // true
Number.isFinite(NaN) // false
Number.isFinite(Infinity) // false
Number.isFinite(-Infinity) // false
Number.isFinite('foo') // false
Number.isFinite('15') // false
Number.isFinite(true) // false
```

##### Number.isNaN()

用来检查一个值是否为NaN。

```js
Number.isNaN(NaN) // true
Number.isNaN(15) // false
Number.isNaN('15') // false
Number.isNaN(true) // false
Number.isNaN(9 / NaN) // true
Number.isNaN('true' / 0) // true
Number.isNaN('true' / 'true') // true
```

##### Number.parseInt()

ES6 将全局方法parseInt()移植到Number对象上面，行为完全保持不变。 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

```js
// ES5的写法
parseInt('12.34') // 12

// ES6的写法
Number.parseInt('12.34') // 12
```

##### Number.parseFloat()

ES6 将全局方法parseFloat()移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。

```js
// ES5的写法
parseFloat('123.45#') // 123.45

// ES6的写法
Number.parseFloat('123.45#') // 123.45
```

##### Number.isInteger()

用来判断一个数值是否为整数。

```js
Number.isInteger(25) // true
Number.isInteger(25.1) // false

Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
```

##### Number.MAX_SAFE_INTEGER

```js
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true

Number.MAX_SAFE_INTEGER === 9007199254740991 // true
```

##### Number.MIN_SAFE_INTEGER

```js
Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true

Number.MIN_SAFE_INTEGER === -9007199254740991 // true
```

##### Number.isSafeInteger()

JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。

```js
Math.pow(2, 53) // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1 // true
```

#### Math扩展

##### Math.trunc()

方法用于去除一个数的小数部分，返回整数部分。

```js
console.log(Math.trunc(5.5))
console.log(Math.trunc(-5.5))
console.log(Math.trunc(true)) // 1
console.log(Math.trunc(false)) // 0
console.log(Math.trunc(NaN)) // NaN
console.log(Math.trunc(undefined)) // NaN
console.log(Math.trunc()) // NaN
```

##### Math.sign()

方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。

它会返回五种值。

- 参数为正数，返回+1
- 参数为负数，返回-1
- 参数为 0，返回0
- 参数为-0，返回-0
- 其他值，返回NaN

```js
console.log(Math.sign(5)) // 1
console.log(Math.sign(-5)) // -1
console.log(Math.sign(0)) // 0
console.log(Math.sign(NaN)) // NaN
console.log(Math.sign(true)) // 1
console.log(Math.sign(false)) // 0
```

##### Math.cbrt()

方法用于计算一个数的立方根。

```js
console.log(Math.cbrt(8)) // 2

console.log(Math.cbrt('LYH')) // NaN
```

### Proxy代理

在 ES6 标准中新增的一个非常强大的功能是 Proxy，它可以自定义一些常用行为如查找、赋值、枚举、函数调用等。通过 Proxy 这个名称也可以看出来它包含了“代理”的含义，只要有“代理”的诉求都可以考虑使用 Proxy 来实现。

#### 基本语法

**语法**

```js
let p = new Proxy(target, handler)
```

**解释**

|  参数   |                             含义                             | 必选 |
| :-----: | :----------------------------------------------------------: | :--: |
| target  | 用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） |  Y   |
| handler |    一个对象，其属性是当执行一个操作时定义代理的行为的函数    |  Y   |

MDN 给出的解释偏官方，通俗的讲第一个参数 target 就是用来代理的“对象”，被代理之后它是不能直接被访问的，而 handler 就是实现代理的过程。

````js
// ES5
let obj = {}
let newVal = ''
Object.defineProperty(obj, 'name', {
    get(){
        return newVal
    },
    set(val){
        console.log('set')
        // this.name = val
        newVal = val
    }
})
obj.name = 'es'

// proxy
let obj = {}
let p = new Proxy(obj, {})
obj.name = 'imooc'
console.log(obj.name)
for(let key in obj){
    console.log(key)
}
````

#### 拦截操作场景

**场景**

我们经常读取一个对象的 key-value：

```js
let o = {
    name: 'XHT',
    age: 18
}

console.log(o.name) // XHT
console.log(o.age) // 18
console.log(o.from) // undefined
```

当我们读取 from 的时候返回的是 undefined，因为 o 这个对象中没有这个 key-value。想想看我们在读取数据的时候，这个数据经常是聚合的，当大家没有按照规范来的时候或者数据缺失的情况下，经常会出现这种“乌龙”现象。

如果我们不想在调用 key 的时候返回 undefined，之前的做法是这样的：

```js
console.log(o.from || '')
```

如果我们对所有代码都是这种写法，那阅读性和观赏性就不得而知了。值得庆幸的是，ES6 的 Proxy 可以让我们轻松的解决这一问题：

```js
let o = {
    name: 'jiaojiao',
    age: 20
}

let handler = {
    get(obj, key) {
        return Reflect.has(obj, key) ? obj[key] : ''
    }
}

let p = new Proxy(o, handler)

console.log(p.from)
```

这个代码是想表达如果 o 对象有这个 key-value 则直接返回，如果没有一律返回 `''` ，当然这里是自定义，大家可以根据自己的需要来写适合自己业务的规则。

刚才对数据的“读操作”进行了拦截，接下来我们描述下“写操作”进行拦截。

**场景 1**

从服务端获取的数据希望是只读，不允许在任何一个环节被修改。

```js
// response.data 是 JSON 格式的数据，来自服务端的响应
// 在 ES5 中只能通过遍历把所有的属性设置为只读
for (let [key] of Object.entries(response.data)) {
    Object.defineProperty(response.data, key, {
        writable: false
    })
}
```

如果我们使用 Proxy 就简单很多了：

```js
let data = new Proxy(response.data, {
    set(obj, key, value) {
        return false
    }
})
```

**场景 2**

对于数据交互而言，校验是不可或缺的一个环境，传统的做法是将校验写在了业务逻辑里，导致代码耦合度较高。如果大家使用 Proxy 就可以将代码设计的非常灵活。

```js
// Validator.js
export default (obj, key, value) => {
    if (Reflect.has(key) && value > 20) {
        obj[key] = value
    }
}

import Validator from './Validator'
let data = new Proxy(response.data, {
    set: Validator
})
```

**场景 3**

如果对读写进行监控，可以这样写：

```js
let validator = {
    set(target, key, value) {
        if (key === 'age') {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                throw new TypeError('Age must be a number')
            }
            if (value <= 0) {
                throw new TypeError('Age must be a positive number')
            }
        }
        return true
    }
}
const person = {
    age: 27
}
const proxy = new Proxy(person, validator)
proxy.age = 'foo'
// <- TypeError: Age must be a number
proxy.age = NaN
// <- TypeError: Age must be a number
proxy.age = 0
// <- TypeError: Age must be a positive number
proxy.age = 28
console.log(person.age)
// <- 28

// 添加监控
window.addEventListener(
    'error',
    e => {
        console.log(e.message) // Uncaught TypeError: Age must be a number
    },
    true
)
```

**场景 4**

什么实例一个对象，每个对象都有一个自己的 id 而且只读。

```js
class Component {
    constructor() {
        this.proxy = new Proxy({
            id: Math.random().toString(36).slice(-8)
        })
    }
    get id() {
        return this.proxy.id
    }
}
```

#### 常用拦截操作

##### get

拦截对象属性的读取，比如proxy.foo和proxy['foo']。

```js
//数组案例
let arr = [7, 8, 9]
arr = new Proxy(arr, {
    get(target, prop) {
        // console.log(target, prop)
        return prop in target ? target[prop] : 'error'
    }
})
console.log(arr[1])
console.log(arr[10])

//对象案例
let dict = {
    'hello': '你好',
    'world': '世界'
}
dict = new Proxy(dict, {
    get(target, prop) {
        return prop in target ? target[prop] : prop
    }
})
console.log(dict['world'])
console.log(dict['imooc'])
```

##### set

拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。

```js
let arr = []
arr = new Proxy(arr, {
    set(target, prop, val) {
        if (typeof val === 'number') {
            target[prop] = val
            return true
        } else {
            return false
        }
    }
})
arr.push(5)
arr.push(6)
console.log(arr[0], arr[1], arr.length)
```

##### has

拦截propKey in proxy的操作，返回一个布尔值。

```js
let range = {
    start: 1,
    end: 5
}

range = new Proxy(range, {
    has(target, prop) {
        return prop >= target.start && prop <= target.end
    }
})
console.log(2 in range)
console.log(9 in range)
```

##### ownKeys

拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。

```js
let obj = {
    name: 'imooc',
    [Symbol('es')]: 'es6'
}
console.log(Object.getOwnPropertyNames(obj))
console.log(Object.getOwnPropertySymbols(obj))
console.log(Object.keys(obj))

for (let key in obj) {
    console.log(key)
}
```

```js
let userinfo = {
    username: 'LeiYan',
    age: 20,
    _password: '***'
}
userinfo = new Proxy(userinfo, {
    ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'))
    }
})

// for (let key in userinfo) {
//     console.log(key)
// }
console.log(Object.keys(userinfo))
```

##### deleteProperty

拦截delete proxy[propKey]的操作，返回一个布尔值。

```js
let user = {
    name: 'xiecheng',
    age: 34,
    _password: '***'
}
user = new Proxy(user, {
    get(target, prop) {
        if (prop.startsWith('_')) {
            throw new Error('不可访问')
        } else {
            return target[prop]
        }
    },
    set(target, prop, val) {
        if (prop.startsWith('_')) {
            throw new Error('不可更改')
        } else {
            target[prop] = val
            return true
        }
    },
    deleteProperty(target, prop) { // 拦截删除
        if (prop.startsWith('_')) {
            throw new Error('不可删除')
        } else {
            delete target[prop]
            return true
        }
    },
    ownKeys(target) {
        return Object.keys(target).filter(key => !key.startsWith('_'))
    }
})
console.log(user.age)
console.log(user._password)
user.age = 18
console.log(user.age)
try {
    user._password = 'xxx'
} catch (e) {
    console.log(e.message)
}

try {
    // delete user.age
    delete user._password
} catch (e) {
    console.log(e.message)
}
console.log(user.age)

for (let key in user) {
    console.log(key)
}
```

##### apply

拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。

```js
let sum = (...args) => {
    let num = 0
    args.forEach(item => {
        num += item
    })
    return num
}

sum = new Proxy(sum, {
    apply(target, ctx, args) {
        return target(...args) * 2
    }
})
console.log(sum(1, 2))
console.log(sum.call(null, 1, 2, 3))
console.log(sum.apply(null, [1, 2, 3]))
```

##### construct

拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。

```js
let User = class {
    constructor(name) {
        this.name = name
    }
}
User = new Proxy(User, {
    construct(target, args, newTarget) {
        console.log('construct')
        return new target(...args)
    }
})
console.log(new User('imooc'))
```

### Reflect 反射

Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。

#### 设计目的

- 将Object属于语言内部的方法放到Reflect上

```js
let obj = {}
let newVal = ''
Reflect.defineProperty(obj, 'name', {
    get() {
        return newVal
    },
    set(val) {
        console.log('set')
        // this.name = val
        newVal = val
    }
})
obj.name = 'es'
console.log(obj.name)
```

- 修改某些Object方法的返回结果，让其变得更合理

```js
// 老写法
try {
    Object.defineProperty(target, property, attributes)
    // success
} catch (e) {
    // failure
}

// 新写法
if (Reflect.defineProperty(target, property, attributes)) {
    // success
} else {
    // failure
}
```

- 让Object操作变成函数行为

```js
// 老写法
'assign' in Object // true

// 新写法
Reflect.has(Object, 'assign') // true
```

- Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。

```js
Proxy(target, {
    set: function(target, name, value, receiver) {
        var success = Reflect.set(target, name, value, receiver)
        if (success) {
            console.log('property ' + name + ' on ' + target + ' set to ' + value)
        }
        return success
    }
})
```

Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法，这些方法与处理器对象的方法相同。Reflect不是一个函数对象，因此它是不可构造的。

> TIP
>
> 与大多数全局对象不同，Reflect没有构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）

#### 常用方法

##### Reflect.apply()

**语法**

> Reflect.apply(target, thisArgument, argumentsList)

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">目标函数</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">thisArgument</td> <td style="text-align: center;">target函数调用时绑定的this对象</td> <td style="text-align: center;">N</td></tr> <tr><td style="text-align: center;">argumentsList</td> <td style="text-align: center;">target函数调用时传入的实参列表，该参数应该是一个类数组的对象</td> <td style="text-align: center;">N</td></tr></tbody></table>

**示例**

```js
Reflect.apply(Math.floor, undefined, [1.75])
// 1

Reflect.apply(String.fromCharCode, undefined, [104, 101, 108, 108, 111])
// "hello"

Reflect.apply(RegExp.prototype.exec, /ab/, ['confabulation']).index
// 4

Reflect.apply(''.charAt, 'ponies', [3])
// "i"
```

**ES5 对比**

该方法与ES5中Function.prototype.apply()方法类似：调用一个方法并且显式地指定this变量和参数列表(arguments) ，参数列表可以是数组，或类似数组的对象。

```js
Function.prototype.apply.call(Math.floor, undefined, [1.75])
```

##### Reflect.construct()

Reflect.construct() 方法的行为有点像 new 操作符 构造函数 ， 相当于运行 new target(...args).

**语法**

> Reflect.construct(target, argumentsList[, newTarget])

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">被运行的目标函数</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">argumentsList</td> <td style="text-align: center;">调用构造函数的数组或者伪数组</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">newTarget</td> <td style="text-align: center;">该参数为构造函数， 参考 new.target 操作符，如果没有newTarget参数， 默认和target一样</td> <td style="text-align: center;">N</td></tr></tbody></table>

| newTarget | 该参数为构造函数， 参考 new.target 操作符，如果没有newTarget参数， 默认和target一样 | N    |
| --------- | ------------------------------------------------------------ | ---- |
|           |                                                              |      |

> [! WARNING] 如果target或者newTarget不是构造函数，抛出TypeError

Reflect.construct允许你使用可变的参数来调用构造函数

```js
var obj = new Foo(...args)
var obj = Reflect.construct(Foo, args)
```

**示例**

```js
var d = Reflect.construct(Date, [1776, 6, 4])
d instanceof Date // true
d.getFullYear() // 1776
```

如果使用 newTarget 参数，则表示继承了 newTarget 这个超类：

```js
function someConstructor() {}
var result = Reflect.construct(Array, [], someConstructor)

Reflect.getPrototypeOf(result) // 输出：someConstructor.prototype
Array.isArray(result) // true
```

##### Reflect.defineProperty()

静态方法 Reflect.defineProperty() 基本等同于 Object.defineProperty() 方法，唯一不同是返回 Boolean 值。

**语法**

> Reflect.defineProperty(target, propertyKey, attributes)

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">目标对象</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">propertyKey</td> <td style="text-align: center;">要定义或修改的属性的名称</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">attributes</td> <td style="text-align: center;">要定义或修改的属性的描述</td> <td style="text-align: center;">Y</td></tr></tbody></table>

**示例**

```js
const student = {}
Reflect.defineProperty(student, 'name', {
    value: 'Mike'
}) // true
student.name // "Mike"
```

##### Reflect.deleteProperty()

Reflect.deleteProperty 允许你删除一个对象上的属性。返回一个 Boolean 值表示该属性是否被成功删除。它几乎与非严格的 delete operator 相同。

**语法**

> Reflect.deleteProperty(target, propertyKey)

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">删除属性的目标对象</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">propertyKey</td> <td style="text-align: center;">将被删除的属性的名称</td> <td style="text-align: center;">Y</td></tr></tbody></table>

**示例**

```js
var obj = {
    x: 1,
    y: 2
}
Reflect.deleteProperty(obj, "x") // true
obj // { y: 2 }

var arr = [1, 2, 3, 4, 5]
Reflect.deleteProperty(arr, "3") // true
arr // [1, 2, 3, , 5]

// 如果属性不存在，返回 true
Reflect.deleteProperty({}, "foo") // true

// 如果属性不可配置，返回 false
Reflect.deleteProperty(Object.freeze({
    foo: 1
}), "foo") // false
```

##### Reflect.get()

Reflect.get() 方法的工作方式，就像从 object (target[propertyKey]) 中获取属性，但它是作为一个函数执行的。

**语法**

> Reflect.get(target, propertyKey[, receiver])

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">需要取值的目标对象</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">propertyKey</td> <td style="text-align: center;">需要获取的值的键值</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">receiver</td> <td style="text-align: center;">如果遇到 getter，此值将提供给目标调用</td> <td style="text-align: center;">N</td></tr></tbody></table>

**示例**

```js
// Object
var obj = {
    x: 1,
    y: 2
}
Reflect.get(obj, 'x') // 1

// Array
Reflect.get(['zero', 'one'], 1) // "one"

// Proxy with a get handler
var x = {
    p: 1
}
var obj = new Proxy(x, {
    get(t, k, r) {
        return k + 'bar'
    }
})
Reflect.get(obj, 'foo') // "foobar"
```

##### Reflect.getOwnPropertyDescriptor()

静态方法 Reflect.getOwnPropertyDescriptor() 与 Object.getOwnPropertyDescriptor() 方法相似。如果在对象中存在，则返回给定的属性的属性描述符，否则返回 undefined。

**语法**

> Reflect.getOwnPropertyDescriptor(target, propertyKey)

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">需要寻找属性的目标对象</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">propertyKey</td> <td style="text-align: center;">获取自己的属性描述符的属性的名称</td> <td style="text-align: center;">N</td></tr></tbody></table>

**示例**

```js
Reflect.getOwnPropertyDescriptor({
    x: 'hello'
}, 'x')
// {value: "hello", writable: true, enumerable: true, configurable: true}

Reflect.getOwnPropertyDescriptor({
    x: 'hello'
}, 'y')
// undefined

Reflect.getOwnPropertyDescriptor([], 'length')
// {value: 0, writable: true, enumerable: false, configurable: false}
```

**对比**

如果该方法的第一个参数不是一个对象（一个原始值），那么将造成 TypeError 错误。而对于 Object.getOwnPropertyDescriptor，非对象的第一个参数将被强制转换为一个对象处理。

```js
Reflect.getOwnPropertyDescriptor("foo", 0)
// TypeError: "foo" is not non-null object

Object.getOwnPropertyDescriptor("foo", 0)
// { value: "f", writable: false, enumerable: true, configurable: false }
```

##### Reflect.getPrototypeOf()

静态方法 Reflect.getPrototypeOf() 与 Object.getPrototypeOf() 方法是一样的。都是返回指定对象的原型（即，内部的 [[Prototype]] 属性的值）。

**语法**

> Reflect.getPrototypeOf(target)

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">获取原型的目标对象</td> <td style="text-align: center;">Y</td></tr></tbody></table>

##### Reflect.has()

Reflect.has 用于检查一个对象是否拥有某个属性， 相当于in 操作符

**语法**

> Reflect.has(target, propertyKey)

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">获取原型的目标对象</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">propertyKey</td> <td style="text-align: center;">属性名，需要检查目标对象是否存在此属性</td> <td style="text-align: center;">Y</td></tr></tbody></table>

##### Reflect.isExtensible()

Reflect.isExtensible 判断一个对象是否可扩展 （即是否能够添加新的属性），它与 Object.isExtensible() 方法一样。

**语法**

> Reflect.isExtensible(target)

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">获取原型的目标对象</td> <td style="text-align: center;">Y</td></tr></tbody></table>

#####  Reflect.ownKeys()

Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))

**语法**

> Reflect.ownKeys(target)

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">获取原型的目标对象</td> <td style="text-align: center;">Y</td></tr></tbody></table>

**示例**

```js
Reflect.ownKeys({
    z: 3,
    y: 2,
    x: 1
}) // [ "z", "y", "x" ]
Reflect.ownKeys([]) // ["length"]

var sym = Symbol.for("comet")
var sym2 = Symbol.for("meteor")
var obj = {
    [sym]: 0,
    "str": 0,
    "773": 0,
    "0": 0,
    [sym2]: 0,
    "-1": 0,
    "8": 0,
    "second str": 0
}
Reflect.ownKeys(obj)
// [ "0", "8", "773", "str", "-1", "second str", Symbol(comet), Symbol(meteor) ]
// Indexes in numeric order,
// strings in insertion order,
// symbols in insertion order
```

##### Reflect.preventExtensions()

Reflect.preventExtensions 方法阻止新属性添加到对象 例如：防止将来对对象的扩展被添加到对象中)。该方法与 Object.preventExtensions() 方法一致

**语法**

> Reflect.preventExtensions(target)

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">获取原型的目标对象</td> <td style="text-align: center;">Y</td></tr></tbody></table>

**示例**

```js
// Objects are extensible by default.
var empty = {}
Reflect.isExtensible(empty) // === true

// ...but that can be changed.
Reflect.preventExtensions(empty)
Reflect.isExtensible(empty) // === false
Reflect.preventExtensions(1)
// TypeError: 1 is not an object

Object.preventExtensions(1)
// 1
```

##### Reflect.set()

Reflect.set 方法允许你在对象上设置属性。它的作用是给属性赋值并且就像 property accessor 语法一样，但是它是以函数的方式。

**语法**

> Reflect.set(target, propertyKey, value[, receiver])

**解释**

<table><thead><tr><th style="text-align: center;">参数</th> <th style="text-align: center;">含义</th> <th style="text-align: center;">必选</th></tr></thead> <tbody><tr><td style="text-align: center;">target</td> <td style="text-align: center;">获取原型的目标对象</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">propertyKey</td> <td style="text-align: center;">设置的属性的名称</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">value</td> <td style="text-align: center;">设置的值</td> <td style="text-align: center;">Y</td></tr> <tr><td style="text-align: center;">receiver</td> <td style="text-align: center;">如果遇到 setter，this 将提供给目标调用</td> <td style="text-align: center;">N</td></tr></tbody></table>

**示例**

```js
// Object
var obj = {}
Reflect.set(obj, "prop", "value") // true
obj.prop // "value"

// Array
var arr = ["duck", "duck", "duck"]
Reflect.set(arr, 2, "goose") // true
arr[2] // "goose"

// It can truncate an array.
Reflect.set(arr, "length", 1) // true
arr // ["duck"]

// With just one argument, propertyKey and value are "undefined".
var obj = {}
Reflect.set(obj) // true
Reflect.getOwnPropertyDescriptor(obj, "undefined")
// { value: undefined, writable: true, enumerable: true, configurable: true }
```

##### Reflect.setPrototypeOf()

Reflect.setPrototypeOf 方法改变指定对象的原型 （即，内部的 [[Prototype]] 属性值）

**语法**

> Reflect.setPrototypeOf(target, prototype)

**解释**

|   参数    |               含义               | 必选 |
| :-------: | :------------------------------: | :--: |
|  target   |        获取原型的目标对象        |  Y   |
| prototype | 对象的新原型 （一个对象或 null） |  Y   |

**示例**

```js
Reflect.setPrototypeOf({}, Object.prototype) // true

// It can change an object's [[Prototype]] to null.
Reflect.setPrototypeOf({}, null) // true

// Returns false if target is not extensible.
Reflect.setPrototypeOf(Object.freeze({}), null) // false

// Returns false if it cause a prototype chain cycle.
var target = {}
var proto = Object.create(target)
Reflect.setPrototypeOf(target, proto) // false
```

<div class="custom-block warning"><p class="custom-block-title">注意</p> <p>对于以上所有 API 第一个参数是 Object 的，如果给定的不是 Object 则抛出一个 TypeError 异常</p></div>

