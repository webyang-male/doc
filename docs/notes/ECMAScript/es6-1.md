### 面向过程 与  面向对象       

> JavaScript是一种基于对象的语言

面向过程是一件事“该怎么做“，面向对象是一件事“该让谁来做”，然后那个“谁”就是对象，他要怎么做是他自己的事，反正最后一群对象合力能把事做好就行了。 				------ 知乎

#### 类和对象

类(class)是对象(object)的模板，定义了同一组对象共有的属性和方法

### 类与继承

#### ES5中的类与继承

##### 类

> 静态方法里的this指向构造函数
>
> 构造函数this指向实例化对象

````js
// 类
function People(name, age) {
    // console.log(this)
    this.name = name
    this.age = age
}
// 实例方法
People.prototype.showName = function () {
    console.log('我的名字是' + this.name)
}
// {name: 'LX', age: 18}
// 我的名字是LX
// {name: 'zhangsan', age: 18}
// 我的名字是zhangsan
let p1 = new People('LX', 18)
console.log(p1)
p1.showName()

let p2 = new People('zhangsan', 18)
console.log(p2)
p2.showName()
````

> 一般情况下，方法不会写在构造函数下(每次实例化都会有一个方法) 一般放在原型上 

```js
// 类
function People(name, age) {
    // console.log(this)
    // 实例属性
    this.name = name
    this.age = age
    People.count++
}
// 静态属性
People.count = 0
// 静态方法
People.getCount = function(){
  /* ƒ People(name, age) {
    console.log(this); // 实例属性
    this.name = name;
    this.age = age;
    People.count++;
  } */
    console.log(this)//指向构造函数
    console.log(this.age) // undefined
    console.log('当前共有' + People.count + '个人')
}

// 实例方法
People.prototype.showName = function () {
    console.log('我的名字是' + this.name)
}

//p1,p2实例化对象
let p1 = new People('lx', 18)
console.log(p1)
p1.showName()

let p2 = new People('zhangsan', 20)
console.log(p2)
p2.showName()

console.log(People.count)
People.getCount()//静态方法调用

// let str = new String('imooc')
// console.log(str)

// let arr = new Array(1, 2, 3)
// console.log(arr)

// let obj = new Object()
// obj.name = 'zain'
// console.log(obj)

// 静态方法
// console.log(Math.max(4, 5))
// console.log(Math.random())
```

##### 继承

> 构造函数继承只能继承父类的属性，原型的继承可以继承方法

`````js
// 父类
function Animal(name) {
    this.name = name
}
Animal.prototype.showName = function () {
    console.log('名字是:' + this.name)
}

// 子类
function Dog(name, color) {
    Animal.call(this, name) // 构造函数继承属性
    this.color = color
}
//原型继承方法
Dog.prototype = new Animal()
//prototype的constructor属性应该是指向它的构造函数的。
//上面这一句让Dog.prototype.constructor指向了Animal，所以需要改回Dog
Dog.prototype.constuctor = Dog

let d1 = new Dog('wangcai', 'white')
console.log(d1)
d1.showName()
//Dog {name: 'wangcai', color: 'white'}
//名字是:wangcai
`````

#### ES6中的类与继承

````js
class People {
    constructor(name, age) {//构造函数constructor
        this.name = name
        this.age = age
        this._sex = -1
    }
    // static count = 0
    get sex() { // 属性
        if (this._sex === 1) {
            return 'male'
        } else if (this._sex === 0) {
            return 'female'
        } else {
            return 'error'
        }
    }
    set sex(val) { // 1:male 0:female
        if (val === 0 || val === 1) {
            this._sex = val
        }
    }
    showName() {
        console.log(this.name)
    }
    // 静态方法
    static getCount() {
        return 5
    }
}
// 静态属性
People.count = 9
console.log(typeof People) // function
console.log(People.count)

let p1 = new People('zain', 18)
console.log(p1)
p1.sex = 5
console.log(p1.sex)
console.log(People.getCount())

//extends实现类之间的继承
class Coder extends People {
    constructor(name, age, company) {
        super(name, age)//super关键字继承父类属性和方法
        this.company = company
    }
    showCompany() {
        console.log(this.company)
    }
}

let c1 = new Coder('zhangsan', 25, 'imooc')
console.log(c1)
c1.showName()
c1.showCompany()
c1.sex = 1
console.log(c1.sex)
console.log(Coder.getCount())
````

##### ✒【拓展理解】

​		<font style="color:deepskyblue;">class实现继承的注意事项</font>

1、class 声明不会提升。Foo 进入暂时性死区，类似于 let、const 声明变量

````js
const bar = new Bar(); // it's ok
function Bar() {
  this.bar = 42;
}

const foo = new Foo(); // ReferenceError: Foo is not defined
class Foo {
  constructor() {
    this.foo = 42;
  }
}
````

2、class 声明内部会启用严格模式

````js
// 引用一个未声明的变量
function Bar() {
  baz = 42; // it's ok
}
const bar = new Bar();

class Foo {
  constructor() {
    fol = 42; // ReferenceError: fol is not defined
  }
}
const foo = new Foo();
````

3、class 的所有方法（包括静态方法和实例方法）都是不可枚举的

````js
// 引用一个未声明的变量
function Bar() {
  this.bar = 42;
}
Bar.answer = function() {
  return 42;
};
Bar.prototype.print = function() {
  console.log(this.bar);
};
const barKeys = Object.keys(Bar); // ['answer']
const barProtoKeys = Object.keys(Bar.prototype); // ['print']

class Foo {
  constructor() {
    this.foo = 42;
  }
  static answer() {
    return 42;
  }
  print() {
    console.log(this.foo);
  }
}
const fooKeys = Object.keys(Foo); // []
const fooProtoKeys = Object.keys(Foo.prototype); // []
````

4、class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用

````js
function Bar() {
  this.bar = 42;
}
Bar.prototype.print = function() {
  console.log(this.bar);
};

const bar = new Bar();
const barPrint = new bar.print(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
  print() {
    console.log(this.foo);
  }
}
const foo = new Foo();
const fooPrint = new foo.print(); // TypeError: foo.print is not a constructor
````

5、必须使用 new 调用 class

```js
function Bar() {
  this.bar = 42;
}
const bar = Bar(); // it's ok

class Foo {
  constructor() {
    this.foo = 42;
  }
}
const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new'
```

6、class 内部无法重写类名

```js
function Bar() {
  Bar = 'Baz'; // it's ok
  this.bar = 42;
}
const bar = new Bar();
// Bar: 'Baz'
// bar: Bar {bar: 42}  

class Foo {
  constructor() {
    this.foo = 42;
    Foo = 'Fol'; // TypeError: Assignment to constant variable
  }
}
const foo = new Foo();
Foo = 'Fol'; // it's ok
```

### 原始数据类型Symbol
